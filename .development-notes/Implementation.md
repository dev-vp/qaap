# Implementation Notes

**Collision Avoidance**

* To ensure unique `SessionKey` and avoid any potential collisions of multiple users, the `SessionKey` is generated by leveraging `Math.random()`, `new Date()`, `Date.prototype.getFullYear()`, `Date.prototype.getMonth()`, `Date.prototype.getDate()`, `Date.prototype.getHours()`, `Date.prototype.getMinutes()`, and `Date.prototype.getMilliseconds()`. The key in this collision avoidance strategy, is simple in design, however, by leveraging not only the 'YYYYMMDDhhmm', the addition of `Math.random()` and `Date.prototype.getMilliseconds()` provide a sufficient level of safety margin to avoid any possible collisions. Furthermore, this also provides useful analytical data on Creation Date/Time, should this information be needed in the future.

**Challenges**

* Database Schema. Inital design was simple without complex relational associations. However, as the build progressed, it soon became more evident that this simple design was not sufficient. As a result, the Database Schema was significantly redesigned, incorporating relational association via Sequelize.
* D3.js integration into React and Redux posed several challenges. For starters, the DOM ownership between D3 vs React had to be determined. And since my implementation leverages D3.js ownership over the DOM (in terms of SVG rendering), this created a second problem. The render/execution of internal React Components and Hooks created 'race conditions' between D3.js, React (i.e. state, props, render), and Redux Thunk (availability of data). As a workaround, conditionals were created to preemptively prevent certain components from rendering before the data was available/fetched.
